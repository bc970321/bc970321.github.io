<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/bbcc.jpg >
    <title>
        bc&#39;s club
    </title>
    <meta name="description" content= 嘿，我是毕成～这是我的博客，欢迎访问！ >
    <meta name="keywords" content= Blog,Hexo,Theme,毕成,bc970321 >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            设计模式
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="设计模式简介-amp-分类"><a href="#设计模式简介-amp-分类" class="headerlink" title="设计模式简介&amp;分类"></a>设计模式简介&amp;分类</h3><p>设计模式是软件开发中常用的一种设计思想，用于解决特定的问题。根据设计模式的分类方式不同，可以有不同的模式数量。</p>
<p>按照常用的分类方式，设计模式可以分为三类：</p>
<p>创建型模式（Creational Patterns）：用于创建对象的模式，包括简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式和单例模式等。</p>
<p>结构型模式（Structural Patterns）：用于描述如何组合类和对象以形成更大的结构，包括适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式和代理模式等。</p>
<p>行为型模式（Behavioral Patterns）：用于描述对象之间的通信方式和职责划分，包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式等。</p>
<h1 id="各个设计模式解决什么问题"><a href="#各个设计模式解决什么问题" class="headerlink" title="各个设计模式解决什么问题"></a>各个设计模式解决什么问题</h1><h3 id="简单工程模式"><a href="#简单工程模式" class="headerlink" title="简单工程模式"></a>简单工程模式</h3><p>简单工厂模式（Simple Factory Pattern）是一种创建型模式，它提供了一种创建对象的统一接口，可以根据不同的参数返回不同类的实例对象，而客户端无需了解这些具体的类。</p>
<p>简单工厂模式一般用于解决以下问题：</p>
<p>需要创建的对象较少：如果只需要创建少量的对象，使用简单工厂模式可以减少代码的复杂性。</p>
<p>客户端不需要知道创建的具体对象：简单工厂模式将创建对象的逻辑封装在工厂类中，客户端只需要调用工厂方法即可获得所需的对象，无需知道具体的创建过程。</p>
<p>代码复用：如果多个客户端需要创建相同的对象，使用简单工厂模式可以避免代码的重复。</p>
<p>需要注意的是，简单工厂模式只适用于创建对象较少的场景，如果需要创建的对象较多，则可以考虑使用工厂方法模式或抽象工厂模式。此外，简单工厂模式也有其缺点，例如增加新的对象类型需要修改工厂类的代码，违反了开闭原则，因此在设计时需要谨慎使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">    Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductA)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Product A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductB)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Product B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory)</span> <span class="title">CreateProduct</span><span class="params">(productType <span class="keyword">string</span>)</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> productType &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;ProductA&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;ProductB&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    factory := &amp;Factory&#123;&#125;</span><br><span class="line"></span><br><span class="line">    productA := factory.CreateProduct(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    productA.Show()</span><br><span class="line"></span><br><span class="line">    productB := factory.CreateProduct(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    productB.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了 <code>Product</code> 接口和两个实现了该接口的具体产品 <code>ProductA</code> 和 <code>ProductB</code>。然后定义了 <code>Factory</code> 工厂类，其中的 <code>CreateProduct</code> 方法根据传入的参数返回不同的产品实例。最后在 <code>main</code> 函数中，我们使用工厂类创建了两个不同的产品并调用其 <code>Show</code> 方法展示出不同的效果。</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式（Factory Method Pattern）是一种创建型模式，它将对象的创建延迟到子类中来实现。工厂方法模式定义了一个用于创建对象的接口，让子类决定将哪一个类实例化。这样做的好处是将对象的创建和使用分离，客户端无需关心对象的创建细节，只需要关心如何使用对象即可。</p>
<p>工厂方法模式一般用于解决以下问题：</p>
<p>需要创建复杂对象：如果需要创建的对象比较复杂，需要进行一系列的初始化操作，使用工厂方法模式可以将这些初始化操作封装到具体的工厂子类中，让客户端更加简单地创建对象。</p>
<p>客户端不需要知道创建的具体对象：工厂方法模式将对象的创建封装在工厂子类中，客户端只需要通过工厂接口创建对象即可，无需知道具体的创建过程。</p>
<p>代码复用：如果多个客户端需要创建相同的对象，使用工厂方法模式可以避免代码的重复。</p>
<p>需要注意的是，工厂方法模式需要为每个产品定义一个具体的工厂子类，如果需要创建的产品很多，会导致类的数量增多，影响代码的可维护性，因此在使用时需要权衡设计的复杂度和代码的可维护性。同时，工厂方法模式也存在一定的开销，因为需要为每个产品定义一个工厂类，可能会导致类的数量增多，影响应用程序的性能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">    Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductA)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Product A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductB)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Product B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateProduct() Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FactoryA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FactoryA)</span> <span class="title">CreateProduct</span><span class="params">()</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductA&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FactoryB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FactoryB)</span> <span class="title">CreateProduct</span><span class="params">()</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    factoryA := &amp;FactoryA&#123;&#125;</span><br><span class="line">    productA := factoryA.CreateProduct()</span><br><span class="line">    productA.Show()</span><br><span class="line"></span><br><span class="line">    factoryB := &amp;FactoryB&#123;&#125;</span><br><span class="line">    productB := factoryB.CreateProduct()</span><br><span class="line">    productB.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了 <code>Product</code> 接口和两个实现了该接口的具体产品 <code>ProductA</code> 和 <code>ProductB</code>。然后定义了 <code>Factory</code> 工厂接口和两个实现了该接口的具体工厂 <code>FactoryA</code> 和 <code>FactoryB</code>，每个工厂实现了自己的 <code>CreateProduct</code> 方法，用于创建对应的产品实例。最后在 <code>main</code> 函数中，我们使用不同的工厂创建了不同的产品并调用其 <code>Show</code> 方法展示出不同的效果。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern）是一种创建型模式，它提供了一种创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>抽象工厂模式一般用于解决以下问题：</p>
<p>需要创建一系列相关或相互依赖的对象：如果需要创建的一系列对象具有相关性或者相互依赖，使用抽象工厂模式可以避免对象之间的耦合度过高。</p>
<p>系统需要独立于它的产品的创建、组合和表示：抽象工厂模式通过封装产品的创建过程，使得系统与具体产品的实现相分离，从而可以方便地替换产品系列，提高系统的灵活性和可维护性。</p>
<p>需要注意的是，抽象工厂模式一般适用于产品族（即相关联的产品组合）的创建，而不是单一产品的创建。此外，抽象工厂模式的缺点是扩展产品族比较困难，因为需要修改抽象工厂接口及其所有实现类，增加系统的复杂度和维护难度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract Product A</span></span><br><span class="line"><span class="keyword">type</span> Pizza <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bake()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Product A1</span></span><br><span class="line"><span class="keyword">type</span> CheesePizza <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *CheesePizza)</span> <span class="title">Bake</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Baking a cheese pizza...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Product A2</span></span><br><span class="line"><span class="keyword">type</span> PepperoniPizza <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PepperoniPizza)</span> <span class="title">Bake</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Baking a pepperoni pizza...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract Product B</span></span><br><span class="line"><span class="keyword">type</span> Beverage <span class="keyword">interface</span> &#123;</span><br><span class="line">    Prepare()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Product B1</span></span><br><span class="line"><span class="keyword">type</span> Coke <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Coke)</span> <span class="title">Prepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Preparing a Coke...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Product B2</span></span><br><span class="line"><span class="keyword">type</span> Sprite <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Sprite)</span> <span class="title">Prepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Preparing a Sprite...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract Factory</span></span><br><span class="line"><span class="keyword">type</span> PizzaAndBeverageFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreatePizza() Pizza</span><br><span class="line">    CreateBeverage() Beverage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Factory 1</span></span><br><span class="line"><span class="keyword">type</span> PizzaAndCokeFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PizzaAndCokeFactory)</span> <span class="title">CreatePizza</span><span class="params">()</span> <span class="title">Pizza</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;CheesePizza&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PizzaAndCokeFactory)</span> <span class="title">CreateBeverage</span><span class="params">()</span> <span class="title">Beverage</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Coke&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Factory 2</span></span><br><span class="line"><span class="keyword">type</span> PizzaAndSpriteFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PizzaAndSpriteFactory)</span> <span class="title">CreatePizza</span><span class="params">()</span> <span class="title">Pizza</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;PepperoniPizza&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PizzaAndSpriteFactory)</span> <span class="title">CreateBeverage</span><span class="params">()</span> <span class="title">Beverage</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Sprite&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    factory1 := &amp;PizzaAndCokeFactory&#123;&#125;</span><br><span class="line">    pizza1 := factory1.CreatePizza()</span><br><span class="line">    beverage1 := factory1.CreateBeverage()</span><br><span class="line">    pizza1.Bake()</span><br><span class="line">    beverage1.Prepare()</span><br><span class="line"></span><br><span class="line">    factory2 := &amp;PizzaAndSpriteFactory&#123;&#125;</span><br><span class="line">    pizza2 := factory2.CreatePizza()</span><br><span class="line">    beverage2 := factory2.CreateBeverage()</span><br><span class="line">    pizza2.Bake()</span><br><span class="line">    beverage2.Prepare()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个示例中，我们定义了两个产品族：<code>Pizza</code> 和 <code>Beverage</code>。<code>Pizza</code> 产品族包含 <code>CheesePizza</code> 和 <code>PepperoniPizza</code> 两种产品，而 <code>Beverage</code> 产品族包含 <code>Coke</code> 和 <code>Sprite</code> 两种产品。</p>
<p>我们还定义了一个抽象工厂接口 <code>PizzaAndBeverageFactory</code>，其中包含两个方法 <code>CreatePizza()</code> 和 <code>CreateBeverage()</code>，分别用于创建 <code>Pizza</code> 和 <code>Beverage</code> 产品。</p>
<p>最后，我们定义了两个具体的工厂类 <code>PizzaAndCokeFactory</code> 和 <code>PizzaAndSpriteFactory</code>，它们分别实现了 <code>PizzaAndBeverageFactory</code> 接口，并实现了 <code>CreatePizza()</code> 和 <code>CreateBeverage()</code> 方法，用于创建具体的产品。</p>
<p>在 <code>main</code> 函数中，我们首先使用 <code>PizzaAndCokeFactory</code> 工厂创建一个 <code>CheesePizza</code> 产品和一个 <code>Coke</code> 产品，然后使用 <code>PizzaAndSpriteFactory</code> 工厂创建一个 <code>PepperoniPizza</code> 产品和一个 <code>Sprite</code> 产品。最后，我们分别调用了这些产品的方法，输出了它们各自的信息。</p>
<p>需要注意的是，如果需要添加一种新的产品族（比如 <code>Dessert</code> 产品族），则需要新增一个新的抽象产品接口 <code>Dessert</code>，以及对应的具体产品类和抽象工厂接口及其实现类。这也是抽象工厂模式的一种缺陷，即扩展产品族比较困难，容易引起类层次结构的复杂度。</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式（Builder Pattern）主要解决的是对象的创建过程过于复杂而导致代码难以维护的问题。当需要创建一个包含多个组成部分的复杂对象时，如果直接在客户端代码中一步步创建每个部分并组装起来，将会导致代码冗长、可读性差、可维护性差等问题。</p>
<p>建造者模式通过将对象的构建过程抽象出来并将其封装在一个独立的 Builder 类中，使得客户端代码只需要关注需要创建的对象的类型和配置参数，而不需要关心其具体的构建过程。这样可以使得代码更加简洁、易于维护，同时也方便了对象的复用和扩展。</p>
<p>建造者模式通常涉及到以下几个角色：</p>
<p>产品（Product）：需要被创建的复杂对象。</p>
<p>抽象建造者（Builder）：定义了对象的构建过程，以及组装对象的方法。</p>
<p>具体建造者（ConcreteBuilder）：实现了抽象建造者的接口，负责具体的对象构建和组装过程。</p>
<p>导演者（Director）：负责组装各个部件，控制构建过程的顺序和逻辑，最终返回完整的对象。</p>
<p>下面是一个简单的 Golang 示例代码，用于创建一份汉堡套餐：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品：汉堡套餐</span></span><br><span class="line"><span class="keyword">type</span> Meal <span class="keyword">struct</span> &#123;</span><br><span class="line">    Burger <span class="keyword">string</span></span><br><span class="line">    Fries  <span class="keyword">bool</span></span><br><span class="line">    Drink  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象建造者：定义了对象的构建过程，以及组装对象的方法</span></span><br><span class="line"><span class="keyword">type</span> MealBuilder <span class="keyword">interface</span> &#123;</span><br><span class="line">    BuildBurger()</span><br><span class="line">    BuildFries()</span><br><span class="line">    BuildDrink()</span><br><span class="line">    GetMeal() Meal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者：实现了抽象建造者的接口，负责具体的对象构建和组装过程</span></span><br><span class="line"><span class="keyword">type</span> CheeseburgerMealBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">    meal Meal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *CheeseburgerMealBuilder)</span> <span class="title">BuildBurger</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.meal.Burger = <span class="string">&quot;Cheeseburger&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *CheeseburgerMealBuilder)</span> <span class="title">BuildFries</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.meal.Fries = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *CheeseburgerMealBuilder)</span> <span class="title">BuildDrink</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.meal.Drink = <span class="string">&quot;Coke&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *CheeseburgerMealBuilder)</span> <span class="title">GetMeal</span><span class="params">()</span> <span class="title">Meal</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.meal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导演者：负责组装各个部件，控制构建过程的顺序和逻辑，最终返回完整的对象</span></span><br><span class="line"><span class="keyword">type</span> Waiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    builder MealBuilder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Waiter)</span> <span class="title">SetBuilder</span><span class="params">(builder MealBuilder)</span></span> &#123;</span><br><span class="line">    w.builder = builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Waiter)</span> <span class="title">Construct</span><span class="params">()</span> <span class="title">Meal</span></span> &#123;</span><br><span class="line">    w.builder.BuildBurger()</span><br><span class="line">    w.builder.BuildFries()</span><br><span class="line">    w.builder.BuildDrink()</span><br><span class="line">    <span class="keyword">return</span> w.builder.GetMeal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    builder := &amp;CheeseburgerMealBuilder&#123;&#125;</span><br><span class="line">    waiter := &amp;Waiter&#123;&#125;</span><br><span class="line">    waiter.SetBuilder(builder)</span><br><span class="line">    meal := waiter.Construct()</span><br><span class="line">    fmt.Println(meal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们首先定义了一个产品 Meal，表示汉堡套餐，包含三个部分：Burger、Fries 和 Drink。然后定义了一个抽象建造者 MealBuilder，其中包含了三个方法 BuildBurger()、BuildFries() 和 BuildDrink()，用于构建不同部分的汉堡套餐，以及一个 GetMeal() 方法，用于返回最终构建完成的汉堡套餐。</p>
<p>接下来，我们定义了具体建造者 CheeseburgerMealBuilder，它实现了 MealBuilder 接口，并负责具体的对象构建和组装过程。在这个例子中，我们使用 CheeseburgerMealBuilder 来创建一份含有 Cheeseburger、Fries 和 Coke 的汉堡套餐。</p>
<p>最后，我们定义了一个导演者 Waiter，它持有一个 MealBuilder 对象，并负责组装各个部件，控制构建过程的顺序和逻辑，最终返回完整的对象。</p>
<p>在 main 函数中，我们首先创建了一个 CheeseburgerMealBuilder 对象和一个 Waiter 对象，然后将 CheeseburgerMealBuilder 对象传给 Waiter 对象。最后，我们通过调用 Waiter 对象的 Construct() 方法来构建汉堡套餐，并输出其内容。可以看到，通过建造者模式，我们可以将对象的构建过程抽象出来并将其与具体的对象实现分离开来，从而更加灵活地构建对象。这使得我们可以通过调整建造者的组装方式，来构建出不同的产品对象，而无需修改产品的具体实现。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式是一种创建型设计模式，它允许通过复制现有对象来创建新对象，而无需向客户端暴露创建逻辑。它可以用于创建那些成本较高的对象，或者那些需要经过复杂计算才能得到的对象。</p>
<p>使用原型模式时，我们首先需要创建一个原型对象，它是我们要创建新对象的基础。然后，我们可以通过复制原型对象来创建新的对象，而不必重新创建这些对象。这个过程通常由一个原型管理器来控制，它维护了一个原型对象的注册表，客户端可以从中获取需要的原型对象，并通过复制来创建新的对象。</p>
<p>原型模式的主要优点是，它能够大幅度减少对象创建的开销，提高了对象创建的效率。同时，它也避免了客户端和创建逻辑之间的耦合，使得客户端无需关心对象的创建过程。此外，由于原型对象通常是通过复制来创建新对象的，因此可以保证新对象与原型对象具有相同的属性和行为。</p>
<p>下面是一个使用 Golang 实现的原型模式的示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型接口：定义了复制自身的方法</span></span><br><span class="line"><span class="keyword">type</span> Prototype <span class="keyword">interface</span> &#123;</span><br><span class="line">    Clone() Prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型：实现了原型接口，可以复制自身来创建新对象</span></span><br><span class="line"><span class="keyword">type</span> ConcretePrototype <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcretePrototype)</span> <span class="title">Clone</span><span class="params">()</span> <span class="title">Prototype</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ConcretePrototype&#123;</span><br><span class="line">        Name: p.Name,</span><br><span class="line">        Age:  p.Age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型管理器：维护了一个原型对象的注册表，客户端可以从中获取需要的原型对象，并通过复制来创建新的对象</span></span><br><span class="line"><span class="keyword">type</span> PrototypeManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    prototypes <span class="keyword">map</span>[<span class="keyword">string</span>]Prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *PrototypeManager)</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, prototype Prototype)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m.prototypes == <span class="literal">nil</span> &#123;</span><br><span class="line">        m.prototypes = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Prototype)</span><br><span class="line">    &#125;</span><br><span class="line">    m.prototypes[name] = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *PrototypeManager)</span> <span class="title">Unregister</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(m.prototypes, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *PrototypeManager)</span> <span class="title">Get</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Prototype</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.prototypes[name].Clone()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建原型管理器并注册原型对象</span></span><br><span class="line">    manager := &amp;PrototypeManager&#123;&#125;</span><br><span class="line">    prototype := &amp;ConcretePrototype&#123;</span><br><span class="line">        Name: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        Age:  <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    manager.Register(<span class="string">&quot;prototype&quot;</span>, prototype)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过原型管理器获取原型对象，并通过复制来创建新对象</span></span><br><span class="line">    clone := manager.Get(<span class="string">&quot;prototype&quot;</span>)</span><br><span class="line">    fmt.Println(clone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们首先定义了一个原型接口 Prototype，它包含了一个 Clone() 方法，用于复制自身来创建新对象。然后，我们定义了一个具体原型 ConcretePrototype，它实现了 Prototype 接口，并可以复制自身来创建新对象。</p>
<p>接下来，我们定义了一个原型管理器 PrototypeManager，它维护了一个原型对象的注册表，客户端可以从中获取需要的原型对象，并通过复制来创建新的对象。其中，Register() 方法用于注册原型对象，Unregister() 方法用于注销原型对象，Get() 方法用于获取原型对象。</p>
<p>在 main() 函数中，我们首先创建了一个原型管理器 manager，并注册了一个原型对象 prototype。然后，我们通过原型管理器获取原型对象，并通过复制来创建新对象，最后输出了新对象的属性值。</p>
<p>总的来说，原型模式主要解决的是创建成本高、创建过程复杂的对象的问题，通过复制现有对象来创建新对象，可以大幅度减少对象创建的开销，提高对象创建的效率，同时也避免了客户端和创建逻辑之间的耦合。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式主要解决的是在系统中保证一个类只有一个实例，并且提供全局访问点，让其他对象可以通过该实例来访问该类的功能的问题。使用单例模式可以避免系统中出现多个相同的实例，减少系统内存占用和资源消耗，同时也方便了对实例的控制和管理。</p>
<p>在单例模式中，一般有两种方式来实现单例：</p>
<p>饿汉式单例：在类加载时就创建单例实例，并提供全局访问点，保证了单例的唯一性和全局可访问性。</p>
<p>懒汉式单例：在第一次调用时才创建单例实例，并提供全局访问点，同时需要处理多线程环境下的并发访问问题，保证了单例的唯一性和全局可访问性。</p>
<p>在实际开发中，单例模式常用于工具类、配置类、日志类、缓存类等。</p>
<p>当涉及到单例模式时，golang 的实现方式与其他面向对象语言有所不同，因为 golang 中没有类的概念，因此也没有类的静态成员变量和构造函数。但是，golang 中的包级别变量和初始化函数可以被用来实现饿汉式单例和懒汉式单例。</p>
<p>下面分别给出饿汉式单例和懒汉式单例的 golang 实现示例代码：</p>
<p>饿汉式单例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一些属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Singleton = &amp;Singleton&#123; <span class="comment">/* 初始化属性 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们首先定义了一个 Singleton 结构体，并在全局范围内创建了一个名为 instance 的包级别变量，该变量在定义时就已经进行了初始化。我们还定义了一个名为 GetInstance 的函数，用于获取 instance 变量的值。由于 instance 变量在定义时就已经进行了初始化，因此可以保证 GetInstance 函数始终返回同一个 Singleton 实例。</p>
<p>懒汉式单例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一些属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;Singleton&#123; <span class="comment">/* 初始化属性 */</span> &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了一个 Singleton 结构体，并在全局范围内创建了一个名为 instance 的包级别变量。我们还定义了一个名为 GetInstance 的函数，用于获取 instance 变量的值。由于 instance 变量没有在定义时进行初始化，因此在第一次调用 GetInstance 函数时，会执行 once.Do 方法中的代码块，创建一个新的 Singleton 实例并赋值给 instance 变量。由于 once.Do 方法只会执行一次，因此可以保证 GetInstance 函数始终返回同一个 Singleton 实例。此外，我们还使用了 sync 包中的 Once 类型来保证在多线程环境下的并发访问问题。</p>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: 毕成 | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
